(import (chicken io)
        (chicken irregex)
        (chicken sort)
        (clojurian syntax)
        srfi-1)

(define (parse line)
  (define (parse-line-half line-half)
    (->> (irregex-split " " line-half)
         (map string->list)
         (map (lambda (seq) (sort seq char<?)))
         (map (lambda (seq) (map (compose string->symbol string) seq)))))
  (let* ((split (irregex-split " \\| " line))
         (patterns (parse-line-half (car split)))
         (output (parse-line-half (cadr split))))
    (values patterns output)))

(define segments '(a b c d e f g))

(define (missing-segs pattern)
  (let loop ((rem-segs segments)
             (rem-pattern pattern)
             (acc '()))
    (cond
      ((null? rem-segs)
       (reverse acc))
      ((null? rem-pattern)
       (append (reverse acc) rem-segs))
      ((eq? (car rem-segs) (car rem-pattern))
       (loop (cdr rem-segs)
             (cdr rem-pattern)
             acc))
      (else
       (loop (cdr rem-segs)
             rem-pattern
             (cons (car rem-segs) acc))))))

(define (solve patterns)
  (let* (;;; Unique lengths
         (one   (find (lambda (pat) (= 2 (length pat))) patterns))
         (four  (find (lambda (pat) (= 4 (length pat))) patterns))
         (seven (find (lambda (pat) (= 3 (length pat))) patterns))
         (eight (find (lambda (pat) (= 7 (length pat))) patterns))
         ;;; Length = 6
         (zero  (find (lambda (pat)
                        (and (= 6 (length pat))
                             (lset<= eq? (missing-segs pat) four)
                             (lset<= eq? (missing-segs pat) (missing-segs one))))
                      patterns))
         (six   (find (lambda (pat)
                        (and (= 6 (length pat))
                             (lset<= eq? (missing-segs pat) one)))
                      patterns))
         (nine  (find (lambda (pat)
                        (and (= 6 (length pat))
                             (lset<= eq? (missing-segs pat) (missing-segs four))))
                      patterns))
         ;;; Length = 5
         (two   (find (lambda (pat)
                        (and (= 5 (length pat))
                             (lset<= eq? (missing-segs pat) four)))
                      patterns))
         (three (find (lambda (pat)
                        (and (= 5 (length pat))
                             (lset<= eq? pat nine)
                             (lset<= eq? (missing-segs pat) six)))
                      patterns))
         (five  (find (lambda (pat)
                        (and (= 5 (length pat))
                             (lset<= eq? pat six)))
                      patterns)))
   `(( ,zero  . 0)
     ( ,one   . 1)
     ( ,two   . 2)
     ( ,three . 3)
     ( ,four  . 4)
     ( ,five  . 5)
     ( ,six   . 6)
     ( ,seven . 7)
     ( ,eight . 8)
     ( ,nine  . 9))))

(define (output-value key output)
  (let ((digits (map (lambda (pat) (cdr (assoc pat key equal?)))
                     output)))
    (fold (lambda (digit acc) (+ (* 10 acc) digit))
          0
          digits)))

(define (main)
  (let loop ((line (read-line))
             (acc 0))
    (if (eof-object? line)
      (begin
        (display acc)
        (newline))
      (let-values (((patterns output) (parse line)))
        (loop (read-line)
              (+ acc
                 (output-value (solve patterns) output)))))))

(main)
